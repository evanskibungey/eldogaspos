/**\n * EldoGas POS Offline Manager\n * Handles offline functionality for the POS system\n */\n\nclass OfflinePOSManager {\n    constructor(config = {}) {\n        this.config = {\n            dbName: config.dbName || 'eldogas_offline_db',\n            dbVersion: config.dbVersion || 1,\n            syncInterval: config.syncInterval || 30000,\n            maxRetries: config.maxRetries || 3,\n            retryDelay: config.retryDelay || 5000,\n            ...config\n        };\n        \n        this.db = null;\n        this.isInitialized = false;\n        this.syncInProgress = false;\n        this.pendingOperations = [];\n        \n        this.initialize();\n    }\n    \n    async initialize() {\n        try {\n            await this.initDatabase();\n            this.setupConnectionMonitoring();\n            this.startPeriodicSync();\n            this.isInitialized = true;\n            console.log('Offline POS Manager initialized successfully');\n        } catch (error) {\n            console.error('Failed to initialize Offline POS Manager:', error);\n            throw error;\n        }\n    }\n    \n    async initDatabase() {\n        return new Promise((resolve, reject) => {\n            const request = indexedDB.open(this.config.dbName, this.config.dbVersion);\n            \n            request.onerror = () => reject(request.error);\n            request.onsuccess = () => {\n                this.db = request.result;\n                resolve();\n            };\n            \n            request.onupgradeneeded = (event) => {\n                const db = event.target.result;\n                \n                // Create stores\n                if (!db.objectStoreNames.contains('sales')) {\n                    const salesStore = db.createObjectStore('sales', { keyPath: 'id', autoIncrement: true });\n                    salesStore.createIndex('receipt_number', 'receipt_number', { unique: true });\n                    salesStore.createIndex('status', 'status');\n                    salesStore.createIndex('created_at', 'created_at');\n                }\n                \n                if (!db.objectStoreNames.contains('sale_items')) {\n                    const itemsStore = db.createObjectStore('sale_items', { keyPath: 'id', autoIncrement: true });\n                    itemsStore.createIndex('sale_id', 'sale_id');\n                }\n                \n                if (!db.objectStoreNames.contains('sync_queue')) {\n                    const syncStore = db.createObjectStore('sync_queue', { keyPath: 'id', autoIncrement: true });\n                    syncStore.createIndex('type', 'type');\n                    syncStore.createIndex('priority', 'priority');\n                    syncStore.createIndex('created_at', 'created_at');\n                }\n                \n                if (!db.objectStoreNames.contains('products_cache')) {\n                    const productsStore = db.createObjectStore('products_cache', { keyPath: 'id' });\n                    productsStore.createIndex('sku', 'sku');\n                    productsStore.createIndex('status', 'status');\n                }\n            };\n        });\n    }\n    \n    setupConnectionMonitoring() {\n        window.addEventListener('online', () => {\n            console.log('Connection restored - starting sync');\n            this.dispatchConnectionEvent(true);\n            this.startBackgroundSync();\n        });\n        \n        window.addEventListener('offline', () => {\n            console.log('Connection lost - switching to offline mode');\n            this.dispatchConnectionEvent(false);\n        });\n    }\n    \n    dispatchConnectionEvent(isOnline) {\n        window.dispatchEvent(new CustomEvent('connection-status-changed', {\n            detail: { isOnline }\n        }));\n    }\n    \n    async processSaleOffline(saleData) {\n        try {\n            const receiptNumber = this.generateReceiptNumber();\n            const timestamp = new Date().toISOString();\n            \n            const sale = {\n                user_id: saleData.user_id,\n                receipt_number: receiptNumber,\n                total_amount: saleData.total_amount,\n                payment_method: saleData.payment_method,\n                payment_status: saleData.payment_method === 'cash' ? 'paid' : 'pending',\n                status: 'completed',\n                created_at: timestamp,\n                updated_at: timestamp,\n                offline_mode: true,\n                customer_details: saleData.customer_details\n            };\n            \n            // Store sale offline\n            const saleId = await this.storeSale(sale);\n            \n            // Store sale items\n            for (const item of saleData.cart_items) {\n                await this.storeSaleItem({\n                    sale_id: saleId,\n                    product_id: item.id,\n                    quantity: item.quantity,\n                    unit_price: item.price,\n                    subtotal: item.price * item.quantity,\n                    serial_number: item.serial_number\n                });\n            }\n            \n            // Add to sync queue\n            await this.addToSyncQueue({\n                type: 'sale',\n                data: { sale, items: saleData.cart_items },\n                priority: 1,\n                created_at: timestamp\n            });\n            \n            return {\n                success: true,\n                receipt_number: receiptNumber,\n                offline_mode: true,\n                message: 'Sale processed offline successfully'\n            };\n            \n        } catch (error) {\n            console.error('Offline sale processing failed:', error);\n            throw new Error('Failed to process sale offline: ' + error.message);\n        }\n    }\n    \n    generateReceiptNumber() {\n        const prefix = 'RCP-OFF-' + new Date().toISOString().slice(0, 10).replace(/-/g, '');\n        const random = Math.random().toString(36).substr(2, 5).toUpperCase();\n        return prefix + '-' + random;\n    }\n    \n    async storeSale(sale) {\n        return new Promise((resolve, reject) => {\n            const transaction = this.db.transaction(['sales'], 'readwrite');\n            const store = transaction.objectStore('sales');\n            const request = store.add(sale);\n            \n            request.onsuccess = () => resolve(request.result);\n            request.onerror = () => reject(request.error);\n        });\n    }\n    \n    async storeSaleItem(item) {\n        return new Promise((resolve, reject) => {\n            const transaction = this.db.transaction(['sale_items'], 'readwrite');\n            const store = transaction.objectStore('sale_items');\n            const request = store.add(item);\n            \n            request.onsuccess = () => resolve(request.result);\n            request.onerror = () => reject(request.error);\n        });\n    }\n    \n    async addToSyncQueue(operation) {\n        return new Promise((resolve, reject) => {\n            const transaction = this.db.transaction(['sync_queue'], 'readwrite');\n            const store = transaction.objectStore('sync_queue');\n            const request = store.add(operation);\n            \n            request.onsuccess = () => resolve(request.result);\n            request.onerror = () => reject(request.error);\n        });\n    }\n    \n    async getPendingOperationsCount() {\n        return new Promise((resolve, reject) => {\n            const transaction = this.db.transaction(['sync_queue'], 'readonly');\n            const store = transaction.objectStore('sync_queue');\n            const request = store.count();\n            \n            request.onsuccess = () => resolve(request.result);\n            request.onerror = () => reject(request.error);\n        });\n    }\n    \n    async getOfflineSalesSummary() {\n        return new Promise((resolve, reject) => {\n            const transaction = this.db.transaction(['sales'], 'readonly');\n            const store = transaction.objectStore('sales');\n            const request = store.getAll();\n            \n            request.onsuccess = () => {\n                const sales = request.result;\n                const offlineSales = sales.filter(sale => sale.offline_mode);\n                \n                resolve({\n                    total_sales: offlineSales.length,\n                    total_amount: offlineSales.reduce((sum, sale) => sum + sale.total_amount, 0),\n                    pending_sync: offlineSales.length\n                });\n            };\n            request.onerror = () => reject(request.error);\n        });\n    }\n    \n    async startBackgroundSync() {\n        if (this.syncInProgress || !navigator.onLine) {\n            return;\n        }\n        \n        this.syncInProgress = true;\n        \n        try {\n            const pendingOperations = await this.getPendingOperations();\n            \n            for (const operation of pendingOperations) {\n                try {\n                    await this.syncOperation(operation);\n                    await this.removeFromSyncQueue(operation.id);\n                } catch (error) {\n                    console.error('Failed to sync operation:', operation, error);\n                    // Continue with next operation\n                }\n            }\n            \n            console.log('Background sync completed');\n        } catch (error) {\n            console.error('Background sync failed:', error);\n        } finally {\n            this.syncInProgress = false;\n        }\n    }\n    \n    async getPendingOperations() {\n        return new Promise((resolve, reject) => {\n            const transaction = this.db.transaction(['sync_queue'], 'readonly');\n            const store = transaction.objectStore('sync_queue');\n            const request = store.getAll();\n            \n            request.onsuccess = () => resolve(request.result);\n            request.onerror = () => reject(request.error);\n        });\n    }\n    \n    async syncOperation(operation) {\n        if (operation.type === 'sale') {\n            // Sync sale to server\n            const response = await fetch('/pos/sales', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'X-CSRF-TOKEN': document.querySelector('meta[name=\"csrf-token\"]').content,\n                    'X-Offline-Sync': 'true'\n                },\n                body: JSON.stringify(operation.data)\n            });\n            \n            if (!response.ok) {\n                throw new Error(`Sync failed: ${response.status} ${response.statusText}`);\n            }\n            \n            const result = await response.json();\n            if (!result.success) {\n                throw new Error(result.message || 'Sync rejected by server');\n            }\n        }\n    }\n    \n    async removeFromSyncQueue(operationId) {\n        return new Promise((resolve, reject) => {\n            const transaction = this.db.transaction(['sync_queue'], 'readwrite');\n            const store = transaction.objectStore('sync_queue');\n            const request = store.delete(operationId);\n            \n            request.onsuccess = () => resolve();\n            request.onerror = () => reject(request.error);\n        });\n    }\n    \n    startPeriodicSync() {\n        setInterval(() => {\n            if (navigator.onLine && !this.syncInProgress) {\n                this.startBackgroundSync();\n            }\n        }, this.config.syncInterval);\n    }\n    \n    showNotification(message, type = 'info') {\n        // Create a simple toast notification\n        const toast = document.createElement('div');\n        toast.className = `fixed top-4 right-4 p-4 rounded-lg shadow-lg z-50 max-w-sm transition-all duration-300 ${\n            type === 'success' ? 'bg-green-500 text-white' :\n            type === 'warning' ? 'bg-orange-500 text-white' :\n            type === 'error' ? 'bg-red-500 text-white' :\n            'bg-blue-500 text-white'\n        }`;\n        \n        toast.innerHTML = `\n            <div class=\"flex items-center\">\n                <span class=\"flex-1\">${message}</span>\n                <button onclick=\"this.parentElement.parentElement.remove()\" class=\"ml-2 text-white hover:text-gray-200\">\n                    <svg class=\"w-4 h-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                        <path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M6 18L18 6M6 6l12 12\"></path>\n                    </svg>\n                </button>\n            </div>\n        `;\n        \n        document.body.appendChild(toast);\n        \n        // Auto remove after 5 seconds\n        setTimeout(() => {\n            if (toast.parentNode) {\n                toast.remove();\n            }\n        }, 5000);\n    }\n}\n\n// Initialize offline manager when script loads\nif (typeof window !== 'undefined') {\n    // Get config from Laravel\n    const offlineConfig = window.offlineConfig || {};\n    \n    // Only initialize if offline mode is enabled\n    if (window.offlineModeEnabled) {\n        console.log('Initializing offline support...');\n        window.offlinePOS = new OfflinePOSManager(offlineConfig);\n    } else {\n        console.log('Offline mode disabled - skipping offline manager initialization');\n    }\n}